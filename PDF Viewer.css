<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Document Viewer Pro</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<style>
/* ========== CSS Custom Properties ========== */
:root {
    --primary-color: #0078d4;
    --primary-hover: #106ebe;
    --success-color: #28a745;
    --success-hover: #218838;
    --error-color: #d32f2f;
    --error-bg: #ffebee;
    --error-border: #ffcdd2;
    --warning-color: #ff9800;
    --info-color: #2196f3;
    --info-bg: #e3f2fd;
    --info-border: #90caf9;
    --controls-bg: #f4f4f4;
    --controls-border: #ddd;
    --text-color: #333;
    --text-muted: #666;
    --canvas-bg: #e0e0e0;
    --page-bg: #fff;
    --shadow: 0 2px 8px rgba(0,0,0,0.15);
    --shadow-lg: 0 4px 20px rgba(0,0,0,0.2);
    --disabled-color: #ccc;
    --transition-speed: 0.2s;
    --sidebar-width: 200px;
    --toolbar-height: 50px;
    --highlight-color: rgba(255, 235, 59, 0.5);
    --highlight-active: rgba(255, 152, 0, 0.6);
}

/* Dark mode */
[data-theme="dark"] {
    --controls-bg: #2d2d2d;
    --controls-border: #444;
    --text-color: #e0e0e0;
    --text-muted: #aaa;
    --canvas-bg: #1a1a1a;
    --page-bg: #2d2d2d;
    --shadow: 0 2px 8px rgba(0,0,0,0.4);
    --info-bg: #1a237e;
    --info-border: #3949ab;
}

/* ========== Base Styles ========== */
* {
    box-sizing: border-box;
}

body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    overflow: hidden;
    background: var(--canvas-bg);
    color: var(--text-color);
}

/* ========== Main Layout ========== */
.app-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    height: 100dvh;
}

.main-content {
    display: flex;
    flex: 1;
    overflow: hidden;
}

/* ========== Configuration Panel ========== */
.config-panel {
    max-width: 500px;
    margin: 40px auto;
    padding: 24px;
    background: var(--page-bg);
    border-radius: 12px;
    box-shadow: var(--shadow-lg);
}

.config-panel h2 {
    margin: 0 0 8px 0;
    font-size: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.config-panel .subtitle {
    color: var(--text-muted);
    margin-bottom: 24px;
    font-size: 14px;
}

.config-section {
    margin-bottom: 20px;
}

.config-section label {
    display: block;
    font-weight: 600;
    margin-bottom: 8px;
    font-size: 14px;
}

.config-section .hint {
    font-size: 12px;
    color: var(--text-muted);
    margin-top: 4px;
}

.config-select {
    width: 100%;
    padding: 12px;
    border: 1px solid var(--controls-border);
    border-radius: 6px;
    font-size: 14px;
    background: var(--page-bg);
    color: var(--text-color);
    cursor: pointer;
}

.config-select:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(0, 120, 212, 0.1);
}

.config-select:disabled {
    background: var(--controls-bg);
    cursor: wait;
}

.config-info {
    background: var(--info-bg);
    border: 1px solid var(--info-border);
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 20px;
    font-size: 13px;
}

.config-info strong {
    color: var(--info-color);
}

.config-detected {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    padding: 16px;
    background: var(--controls-bg);
    border-radius: 8px;
}

.config-detected-item {
    flex: 1;
}

.config-detected-item .label {
    font-size: 11px;
    text-transform: uppercase;
    color: var(--text-muted);
    margin-bottom: 4px;
}

.config-detected-item .value {
    font-weight: 600;
    font-size: 14px;
}

.config-detected-item .value.success {
    color: var(--success-color);
}

.config-detected-item .value.error {
    color: var(--error-color);
}

.config-btn {
    width: 100%;
    padding: 14px 20px;
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.config-btn:hover {
    background: var(--primary-hover);
}

.config-btn:disabled {
    background: var(--disabled-color);
    cursor: not-allowed;
}

.config-btn.secondary {
    background: transparent;
    color: var(--primary-color);
    border: 1px solid var(--primary-color);
    margin-top: 12px;
}

.config-btn.secondary:hover {
    background: rgba(0, 120, 212, 0.1);
}

.loading-inline {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

.no-files-message {
    text-align: center;
    padding: 20px;
    color: var(--text-muted);
}

/* ========== Toolbar ========== */
#toolbar {
    background-color: var(--controls-bg);
    padding: 8px 12px;
    border-bottom: 1px solid var(--controls-border);
    display: flex;
    align-items: center;
    gap: 8px;
    min-height: var(--toolbar-height);
    flex-wrap: wrap;
    position: relative;
    z-index: 100;
}

.toolbar-group {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 0 8px;
    border-right: 1px solid var(--controls-border);
}

.toolbar-group:last-child {
    border-right: none;
}

.toolbar-group.search-group {
    flex: 1;
    max-width: 300px;
    min-width: 150px;
}

#toolbar button {
    padding: 8px 10px;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    white-space: nowrap;
    transition: background-color var(--transition-speed), transform var(--transition-speed);
    touch-action: manipulation;
    display: flex;
    align-items: center;
    gap: 4px;
}

#toolbar button:hover {
    background-color: var(--primary-hover);
}

#toolbar button:active {
    transform: scale(0.96);
}

#toolbar button:disabled {
    background-color: var(--disabled-color);
    cursor: not-allowed;
    transform: none;
}

#toolbar button.icon-btn {
    padding: 8px;
    min-width: 36px;
    justify-content: center;
}

#toolbar button.active {
    background-color: var(--success-color);
}

#toolbar button.toggle-btn {
    background-color: transparent;
    color: var(--text-color);
    border: 1px solid var(--controls-border);
}

#toolbar button.toggle-btn:hover {
    background-color: rgba(0,0,0,0.05);
}

#toolbar button.toggle-btn.active {
    background-color: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

/* Column selector in toolbar */
#columnSelector {
    padding: 6px 10px;
    border: 1px solid var(--controls-border);
    border-radius: 4px;
    font-size: 13px;
    background: var(--page-bg);
    color: var(--text-color);
    cursor: pointer;
    max-width: 200px;
}

/* ========== Input Styles ========== */
#toolbar input[type="text"],
#toolbar input[type="number"] {
    padding: 6px 10px;
    border: 1px solid var(--controls-border);
    border-radius: 4px;
    font-size: 13px;
    background: var(--page-bg);
    color: var(--text-color);
}

#toolbar input[type="number"] {
    width: 60px;
    text-align: center;
}

#toolbar select {
    padding: 6px 10px;
    border: 1px solid var(--controls-border);
    border-radius: 4px;
    font-size: 13px;
    background: var(--page-bg);
    color: var(--text-color);
    cursor: pointer;
}

.search-input-wrapper {
    position: relative;
    flex: 1;
}

#searchInput {
    width: 100%;
    padding-right: 60px !important;
}

.search-nav {
    position: absolute;
    right: 4px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    gap: 2px;
}

.search-nav button {
    padding: 4px 6px !important;
    font-size: 11px !important;
    min-width: auto !important;
}

#searchResults {
    font-size: 11px;
    color: var(--text-muted);
    white-space: nowrap;
}

/* ========== Page Navigation ========== */
.page-nav {
    display: flex;
    align-items: center;
    gap: 4px;
}

.page-nav span {
    font-size: 13px;
    color: var(--text-muted);
}

#pageInput {
    width: 50px;
}

/* ========== Sidebar ========== */
#sidebar {
    width: var(--sidebar-width);
    background: var(--controls-bg);
    border-right: 1px solid var(--controls-border);
    display: flex;
    flex-direction: column;
    transition: width 0.3s ease, margin-left 0.3s ease;
    overflow: hidden;
}

#sidebar.collapsed {
    width: 0;
    margin-left: calc(var(--sidebar-width) * -1);
}

.sidebar-tabs {
    display: flex;
    border-bottom: 1px solid var(--controls-border);
}

.sidebar-tab {
    flex: 1;
    padding: 10px;
    text-align: center;
    cursor: pointer;
    font-size: 12px;
    border: none;
    background: transparent;
    color: var(--text-muted);
    transition: all 0.2s;
}

.sidebar-tab:hover {
    background: rgba(0,0,0,0.05);
}

.sidebar-tab.active {
    color: var(--primary-color);
    border-bottom: 2px solid var(--primary-color);
    font-weight: 600;
}

.sidebar-content {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
}

.sidebar-panel {
    display: none;
}

.sidebar-panel.active {
    display: block;
}

/* Thumbnails */
.thumbnail-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.thumbnail-item {
    cursor: pointer;
    border: 2px solid transparent;
    border-radius: 4px;
    overflow: hidden;
    transition: all 0.2s;
    background: var(--page-bg);
}

.thumbnail-item:hover {
    border-color: var(--primary-color);
    transform: scale(1.02);
}

.thumbnail-item.active {
    border-color: var(--primary-color);
    box-shadow: var(--shadow);
}

.thumbnail-item canvas {
    display: block;
    width: 100%;
    height: auto;
}

.thumbnail-label {
    text-align: center;
    font-size: 11px;
    padding: 4px;
    color: var(--text-muted);
    background: rgba(0,0,0,0.03);
}

/* Outline/Bookmarks */
.outline-item {
    padding: 8px 12px;
    cursor: pointer;
    font-size: 13px;
    border-radius: 4px;
    transition: background 0.2s;
}

.outline-item:hover {
    background: rgba(0,0,0,0.05);
}

.outline-item.level-1 { padding-left: 12px; font-weight: 600; }
.outline-item.level-2 { padding-left: 24px; }
.outline-item.level-3 { padding-left: 36px; font-size: 12px; }

/* ========== Canvas Container ========== */
#canvas {
    flex: 1;
    background-color: var(--canvas-bg);
    overflow: auto;
    position: relative;
    scroll-behavior: smooth;
    cursor: default;
}

#canvas.grabbing {
    cursor: grabbing;
}

#canvas .page-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    min-height: 100%;
}

#canvas canvas,
#canvas img {
    display: block;
    margin: 10px auto;
    box-shadow: var(--shadow);
    background: var(--page-bg);
}

.pdf-page-wrapper {
    position: relative;
    margin: 10px auto;
}

.pdf-page {
    display: block;
    box-shadow: var(--shadow);
    background: var(--page-bg);
}

/* Text layer for selection and search */
.text-layer {
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    overflow: hidden;
    opacity: 0.2;
    line-height: 1.0;
    pointer-events: all;
}

.text-layer > span {
    color: transparent;
    position: absolute;
    white-space: pre;
    cursor: text;
    transform-origin: 0% 0%;
}

.text-layer ::selection {
    background: var(--primary-color);
    opacity: 0.5;
}

.text-layer .highlight {
    background-color: var(--highlight-color);
    border-radius: 2px;
}

.text-layer .highlight.active {
    background-color: var(--highlight-active);
}

/* Placeholder */
.pdf-page-placeholder {
    margin: 10px auto;
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    border-radius: 4px;
    box-shadow: var(--shadow);
}

[data-theme="dark"] .pdf-page-placeholder {
    background: linear-gradient(90deg, #3a3a3a 25%, #4a4a4a 50%, #3a3a3a 75%);
    background-size: 200% 100%;
}

@keyframes shimmer {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* ========== Loading & Progress ========== */
.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255,255,255,0.9);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 50;
}

[data-theme="dark"] .loading-overlay {
    background: rgba(0,0,0,0.8);
}

.loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid var(--controls-border);
    border-top-color: var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.loading-text {
    margin-top: 16px;
    font-size: 14px;
    color: var(--text-muted);
}

.progress-container {
    width: 200px;
    height: 6px;
    background: var(--disabled-color);
    border-radius: 3px;
    margin-top: 16px;
    overflow: hidden;
}

.progress-bar {
    height: 100%;
    background: var(--primary-color);
    border-radius: 3px;
    transition: width 0.3s ease;
    width: 0%;
}

/* ========== Error Message ========== */
.error-container {
    text-align: center;
    padding: 40px;
}

.error-icon {
    font-size: 48px;
    margin-bottom: 16px;
}

.error-message {
    color: var(--error-color);
    background-color: var(--error-bg);
    border: 1px solid var(--error-border);
    padding: 16px 24px;
    border-radius: 8px;
    display: inline-block;
    margin-bottom: 16px;
}

/* ========== Offline Banner ========== */
.offline-banner {
    background: var(--warning-color);
    color: white;
    text-align: center;
    padding: 8px;
    font-size: 14px;
    display: none;
}

.offline-banner.visible {
    display: block;
}

/* ========== Document Info Panel ========== */
.doc-info-panel {
    position: absolute;
    top: 60px;
    right: 20px;
    background: var(--page-bg);
    border: 1px solid var(--controls-border);
    border-radius: 8px;
    padding: 16px;
    box-shadow: var(--shadow-lg);
    z-index: 200;
    min-width: 250px;
    display: none;
}

.doc-info-panel.visible {
    display: block;
}

.doc-info-panel h3 {
    margin: 0 0 12px 0;
    font-size: 14px;
    border-bottom: 1px solid var(--controls-border);
    padding-bottom: 8px;
}

.doc-info-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 13px;
}

.doc-info-row .label {
    color: var(--text-muted);
}

.doc-info-row .value {
    font-weight: 500;
    text-align: right;
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* ========== Keyboard Shortcuts Modal ========== */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal-overlay.visible {
    display: flex;
}

.modal-content {
    background: var(--page-bg);
    border-radius: 12px;
    padding: 24px;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: var(--shadow-lg);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.modal-header h2 {
    margin: 0;
    font-size: 18px;
}

.modal-close {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: var(--text-muted);
    padding: 0;
    line-height: 1;
}

.shortcut-list {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 8px 16px;
}

.shortcut-key {
    display: inline-flex;
    gap: 4px;
}

.shortcut-key kbd {
    background: var(--controls-bg);
    border: 1px solid var(--controls-border);
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 12px;
    font-family: monospace;
    min-width: 28px;
    text-align: center;
}

.shortcut-desc {
    color: var(--text-muted);
    font-size: 13px;
    display: flex;
    align-items: center;
}

/* ========== Responsive ========== */
@media (max-width: 900px) {
    #sidebar {
        position: absolute;
        left: 0;
        top: var(--toolbar-height);
        bottom: 0;
        z-index: 90;
        box-shadow: var(--shadow-lg);
    }
    
    #sidebar.collapsed {
        margin-left: 0;
        width: 0;
    }
}

@media (max-width: 768px) {
    #toolbar {
        padding: 6px 8px;
        gap: 4px;
    }
    
    .toolbar-group {
        padding: 0 4px;
    }
    
    .toolbar-group.search-group {
        order: 10;
        flex-basis: 100%;
        max-width: none;
        border-right: none;
        padding-top: 4px;
    }
    
    #toolbar button {
        padding: 8px;
    }
    
    #toolbar button .btn-text {
        display: none;
    }
    
    .page-nav span.page-sep {
        display: none;
    }
    
    #sidebar {
        width: 160px;
    }
    
    .config-panel {
        margin: 20px;
        padding: 16px;
    }
    
    .config-detected {
        flex-direction: column;
        gap: 12px;
    }
}

@media (max-width: 480px) {
    :root {
        --toolbar-height: 45px;
    }
    
    #toolbar button {
        padding: 6px;
        font-size: 14px;
    }
    
    .doc-info-panel {
        left: 10px;
        right: 10px;
        min-width: auto;
    }
    
    #columnSelector {
        max-width: 120px;
    }
}

/* ========== Fullscreen ========== */
.app-container:fullscreen #toolbar,
.app-container:-webkit-full-screen #toolbar {
    padding: 12px 20px;
}

/* ========== Print ========== */
@media print {
    #toolbar, #sidebar, .offline-banner, .modal-overlay, .doc-info-panel, .config-panel {
        display: none !important;
    }
    
    #canvas {
        overflow: visible;
        height: auto;
    }
    
    .pdf-page-wrapper {
        page-break-after: always;
        margin: 0;
        box-shadow: none;
    }
}
</style>
</head>
<body>

<div class="app-container" id="appContainer">
    <div class="offline-banner" id="offlineBanner" role="alert">
        ‚ö†Ô∏è You are currently offline. Some features may be unavailable.
    </div>

    <!-- Main Toolbar -->
    <div id="toolbar" role="toolbar" aria-label="Document controls" style="display: none;">
        <!-- Sidebar Toggle -->
        <div class="toolbar-group">
            <button id="sidebarToggle" class="icon-btn toggle-btn active" onclick="toggleSidebar()" aria-label="Toggle sidebar" title="Toggle sidebar (B)">
                ‚ò∞
            </button>
        </div>

        <!-- File Column Selector -->
        <div class="toolbar-group">
            <select id="columnSelector" onchange="onColumnChange(this.value)" title="Select file column"></select>
        </div>

        <!-- Zoom Controls -->
        <div class="toolbar-group">
            <button class="icon-btn" onclick="zoomOut()" aria-label="Zoom out" title="Zoom out (-)">‚àí</button>
            <select id="zoomSelect" onchange="setZoom(this.value)" aria-label="Zoom level">
                <option value="auto">Auto</option>
                <option value="page-fit">Fit Page</option>
                <option value="page-width">Fit Width</option>
                <option value="0.5">50%</option>
                <option value="0.75">75%</option>
                <option value="1" selected>100%</option>
                <option value="1.25">125%</option>
                <option value="1.5">150%</option>
                <option value="2">200%</option>
                <option value="3">300%</option>
            </select>
            <button class="icon-btn" onclick="zoomIn()" aria-label="Zoom in" title="Zoom in (+)">+</button>
        </div>

        <!-- Page Navigation -->
        <div class="toolbar-group page-nav">
            <button class="icon-btn" id="prevPage" onclick="previousPage()" disabled aria-label="Previous page" title="Previous page (‚Üê)">‚óÄ</button>
            <input type="number" id="pageInput" min="1" value="1" onchange="goToPage(this.value)" aria-label="Page number">
            <span class="page-sep">of</span>
            <span id="totalPages">0</span>
            <button class="icon-btn" id="nextPage" onclick="nextPage()" disabled aria-label="Next page" title="Next page (‚Üí)">‚ñ∂</button>
        </div>

        <!-- Rotate -->
        <div class="toolbar-group">
            <button class="icon-btn" onclick="rotateLeft()" aria-label="Rotate left" title="Rotate left">‚Ü∂</button>
            <button class="icon-btn" onclick="rotateRight()" aria-label="Rotate right" title="Rotate right (R)">‚Ü∑</button>
        </div>

        <!-- Search -->
        <div class="toolbar-group search-group">
            <div class="search-input-wrapper">
                <input type="text" id="searchInput" placeholder="Search... (Ctrl+F)" aria-label="Search text" onkeydown="handleSearchKeydown(event)">
                <div class="search-nav">
                    <button onclick="searchPrev()" title="Previous match">‚ñ≤</button>
                    <button onclick="searchNext()" title="Next match">‚ñº</button>
                </div>
            </div>
            <span id="searchResults"></span>
        </div>

        <!-- Actions -->
        <div class="toolbar-group">
            <button class="icon-btn toggle-btn" id="darkModeToggle" onclick="toggleDarkMode()" aria-label="Toggle dark mode" title="Dark mode (D)">üåô</button>
            <button class="icon-btn" onclick="printDocument()" aria-label="Print" title="Print (Ctrl+P)">üñ®Ô∏è</button>
            <button class="icon-btn" onclick="toggleFullscreen()" aria-label="Fullscreen" title="Fullscreen (F)">‚õ∂</button>
            <button class="icon-btn" onclick="showDocInfo()" aria-label="Document info" title="Document info (I)">‚ÑπÔ∏è</button>
            <button class="icon-btn" onclick="downloadFile()" aria-label="Download" title="Download">üì•</button>
            <button class="icon-btn" onclick="showShortcuts()" aria-label="Keyboard shortcuts" title="Keyboard shortcuts (?)">‚å®Ô∏è</button>
        </div>
    </div>

    <div class="main-content">
        <!-- Sidebar -->
        <div id="sidebar" style="display: none;">
            <div class="sidebar-tabs">
                <button class="sidebar-tab active" onclick="showSidebarPanel('thumbnails')" data-panel="thumbnails">Thumbnails</button>
                <button class="sidebar-tab" onclick="showSidebarPanel('outline')" data-panel="outline">Outline</button>
            </div>
            <div class="sidebar-content">
                <div id="thumbnailsPanel" class="sidebar-panel active">
                    <div id="thumbnailContainer" class="thumbnail-container"></div>
                </div>
                <div id="outlinePanel" class="sidebar-panel">
                    <div id="outlineContainer"></div>
                </div>
            </div>
        </div>

        <!-- Main Canvas -->
        <div id="canvas" tabindex="0" role="document" aria-label="Document viewer">
            <div class="loading-overlay" id="loadingOverlay">
                <div class="loading-spinner"></div>
                <div class="loading-text" id="loadingText">Loading document...</div>
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Document Info Panel -->
    <div class="doc-info-panel" id="docInfoPanel">
        <h3>üìÑ Document Information</h3>
        <div id="docInfoContent"></div>
    </div>

    <!-- Keyboard Shortcuts Modal -->
    <div class="modal-overlay" id="shortcutsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
                <button class="modal-close" onclick="hideShortcuts()">&times;</button>
            </div>
            <div class="shortcut-list">
                <div class="shortcut-key"><kbd>‚Üê</kbd> <kbd>‚Üí</kbd></div>
                <div class="shortcut-desc">Previous / Next page</div>
                
                <div class="shortcut-key"><kbd>Home</kbd> <kbd>End</kbd></div>
                <div class="shortcut-desc">First / Last page</div>
                
                <div class="shortcut-key"><kbd>+</kbd> <kbd>-</kbd></div>
                <div class="shortcut-desc">Zoom in / out</div>
                
                <div class="shortcut-key"><kbd>0</kbd></div>
                <div class="shortcut-desc">Reset zoom to 100%</div>
                
                <div class="shortcut-key"><kbd>R</kbd></div>
                <div class="shortcut-desc">Rotate right</div>
                
                <div class="shortcut-key"><kbd>Ctrl</kbd><kbd>F</kbd></div>
                <div class="shortcut-desc">Search in document</div>
                
                <div class="shortcut-key"><kbd>Enter</kbd></div>
                <div class="shortcut-desc">Next search result</div>
                
                <div class="shortcut-key"><kbd>Shift</kbd><kbd>Enter</kbd></div>
                <div class="shortcut-desc">Previous search result</div>
                
                <div class="shortcut-key"><kbd>Esc</kbd></div>
                <div class="shortcut-desc">Clear search / Close modal</div>
                
                <div class="shortcut-key"><kbd>F</kbd></div>
                <div class="shortcut-desc">Toggle fullscreen</div>
                
                <div class="shortcut-key"><kbd>B</kbd></div>
                <div class="shortcut-desc">Toggle sidebar</div>
                
                <div class="shortcut-key"><kbd>D</kbd></div>
                <div class="shortcut-desc">Toggle dark mode</div>
                
                <div class="shortcut-key"><kbd>I</kbd></div>
                <div class="shortcut-desc">Document info</div>
                
                <div class="shortcut-key"><kbd>?</kbd></div>
                <div class="shortcut-desc">Show this help</div>
            </div>
        </div>
    </div>
</div>

<script type="text/javascript">
(function() {
    'use strict';
    
    // ========== Constants ==========
    const CONFIG = {
        DEFAULT_SCALE: 1.0,
        MIN_SCALE: 0.25,
        MAX_SCALE: 5.0,
        ZOOM_STEP: 1.25,
        RENDER_BUFFER_PX: 500,
        THUMBNAIL_SCALE: 0.2,
        SCROLL_THROTTLE_MS: 100,
        IMAGE_EXTENSIONS: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff', 'tif'],
        PDF_EXTENSIONS: ['pdf'],
        PDF_WORKER_URL: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js',
        PDF_CMAP_URL: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
        STORAGE_KEY_PREFIX: 'docViewer_'
    };

    // ========== Auto-detected Configuration ==========
    const viewerConfig = {
        tableName: null,           // Logical name (singular): rsm_contractreview
        tableSetName: null,        // Entity set name (plural): rsm_contractreviews
        recordId: null,
        fileColumns: [],           // Array of {logicalName, displayName, hasFile}
        selectedColumn: null,
        defaultColumn: null,       // Set via Custom Parameter (data) field: fileColumn=rsm_myfile
        baseUrl: window.location.origin
    };

    // ========== Parse Custom Parameters ==========
    function parseCustomParameters() {
        const urlParams = new URLSearchParams(window.location.search);
        
        // D365 passes custom parameters in the 'data' field
        const dataParam = urlParams.get('data');
        if (dataParam) {
            try {
                const decoded = decodeURIComponent(dataParam);
                const dataParams = new URLSearchParams(decoded);
                
                // Get default file column if specified
                viewerConfig.defaultColumn = dataParams.get('fileColumn') || dataParams.get('column') || null;
                
                console.log('Custom parameter - defaultColumn:', viewerConfig.defaultColumn);
            } catch (e) {
                console.log('Could not parse data parameter:', e);
            }
        }
        
        // Also check direct URL params (for testing)
        viewerConfig.defaultColumn = viewerConfig.defaultColumn || urlParams.get('fileColumn') || urlParams.get('column');
    }

    // ========== State ==========
    const state = {
        pdfDoc: null,
        currentScale: CONFIG.DEFAULT_SCALE,
        currentRotation: 0,
        currentFileUrl: '',
        currentFileName: '',
        currentFileType: '',
        currentPage: 1,
        totalPages: 0,
        renderedPages: new Map(),
        isScrollMode: true,
        isLoading: false,
        loadController: null,
        fitMode: null,
        pageViewports: [],
        searchText: '',
        searchMatches: [],
        currentMatchIndex: -1,
        textContent: new Map(),
        isDragging: false,
        dragStart: { x: 0, y: 0, scrollLeft: 0, scrollTop: 0 },
        touchState: { initialPinchDistance: 0, initialScale: 1 },
        sidebarVisible: true,
        darkMode: false,
        docInfo: null
    };

    // ========== DOM Elements ==========
    const elements = {};

    // ========== Utility Functions ==========
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    function throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function getFileExtension(filename) {
        if (!filename || !filename.includes('.')) return '';
        return filename.split('.').pop().toLowerCase();
    }

    function detectFileType(fileName) {
        if (fileName && fileName.includes('.')) {
            const ext = getFileExtension(fileName);
            if (CONFIG.IMAGE_EXTENSIONS.includes(ext)) return 'image';
            if (CONFIG.PDF_EXTENSIONS.includes(ext)) return 'pdf';
        }
        return 'pdf';
    }

    function addCacheBuster(url) {
        const sep = url.includes('?') ? '&' : '?';
        return `${url}${sep}cache=${Date.now()}`;
    }

    // ========== Storage ==========
    function getStorageKey() {
        return `${CONFIG.STORAGE_KEY_PREFIX}${viewerConfig.tableName}`;
    }

    function saveColumnPreference(columnName) {
        try {
            const prefs = JSON.parse(localStorage.getItem(getStorageKey()) || '{}');
            prefs.selectedColumn = columnName;
            localStorage.setItem(getStorageKey(), JSON.stringify(prefs));
        } catch (e) {
            console.log('Could not save column preference:', e);
        }
    }

    function loadColumnPreference() {
        try {
            const prefs = JSON.parse(localStorage.getItem(getStorageKey()) || '{}');
            return prefs.selectedColumn || null;
        } catch (e) {
            return null;
        }
    }

    function saveViewPreferences() {
        try {
            const prefs = JSON.parse(localStorage.getItem(getStorageKey()) || '{}');
            prefs.darkMode = state.darkMode;
            prefs.sidebarVisible = state.sidebarVisible;
            localStorage.setItem(getStorageKey(), JSON.stringify(prefs));
        } catch (e) {}
    }

    function loadViewPreferences() {
        try {
            const prefs = JSON.parse(localStorage.getItem(getStorageKey()) || '{}');
            if (prefs.darkMode) toggleDarkMode(true);
            if (prefs.sidebarVisible === false) toggleSidebar(true);
        } catch (e) {}
    }

    // ========== D365 Context Detection ==========
    function getXrmContext() {
        // Try various ways to get Xrm context
        try {
            if (typeof Xrm !== 'undefined') return Xrm;
            if (typeof parent !== 'undefined' && parent.Xrm) return parent.Xrm;
            if (typeof window.parent !== 'undefined' && window.parent.Xrm) return window.parent.Xrm;
        } catch (e) {}
        return null;
    }

    function getFormContext() {
        const xrm = getXrmContext();
        if (!xrm) return null;
        
        try {
            // UCI - modern approach
            if (xrm.Page && xrm.Page.data) return xrm.Page;
            
            // Alternative: get from parent frames
            if (typeof parent !== 'undefined') {
                for (let i = 0; i < 5; i++) {
                    try {
                        let p = parent;
                        for (let j = 0; j < i; j++) p = p.parent;
                        if (p.Xrm && p.Xrm.Page && p.Xrm.Page.data) return p.Xrm.Page;
                    } catch (e) {}
                }
            }
        } catch (e) {}
        return null;
    }

    async function detectFormContext() {
        console.log('=== Auto-detecting form context ===');
        
        const formContext = getFormContext();
        
        if (formContext) {
            try {
                // Get entity name
                viewerConfig.tableName = formContext.data.entity.getEntityName();
                console.log('Detected table name:', viewerConfig.tableName);
                
                // Get record ID
                viewerConfig.recordId = formContext.data.entity.getId().replace(/[{}]/g, '');
                console.log('Detected record ID:', viewerConfig.recordId);
                
                return true;
            } catch (e) {
                console.error('Error reading form context:', e);
            }
        }
        
        // Fallback: try URL parameters
        console.log('Form context not available, trying URL parameters...');
        const urlParams = new URLSearchParams(window.location.search);
        
        // Log all params for debugging
        console.log('URL Parameters:');
        for (const [key, value] of urlParams.entries()) {
            console.log(`  ${key}: ${value}`);
        }
        
        viewerConfig.recordId = urlParams.get('id')?.replace(/[{}]/g, '');
        viewerConfig.tableName = urlParams.get('typename') || urlParams.get('etn');
        
        // Try to get from data parameter
        const dataParam = urlParams.get('data');
        if (dataParam) {
            try {
                const dataParams = new URLSearchParams(decodeURIComponent(dataParam));
                viewerConfig.recordId = viewerConfig.recordId || dataParams.get('id')?.replace(/[{}]/g, '');
                viewerConfig.tableName = viewerConfig.tableName || dataParams.get('typename') || dataParams.get('table');
            } catch (e) {}
        }
        
        // Try GUID extraction from URL
        if (!viewerConfig.recordId) {
            const guidMatch = window.location.href.match(/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/i);
            if (guidMatch) {
                viewerConfig.recordId = guidMatch[0];
                console.log('Extracted record ID from URL:', viewerConfig.recordId);
            }
        }
        
        return !!(viewerConfig.tableName && viewerConfig.recordId);
    }

    // ========== Metadata & File Column Discovery ==========
    async function getEntitySetName(logicalName) {
        try {
            const response = await fetch(
                `${viewerConfig.baseUrl}/api/data/v9.2/EntityDefinitions(LogicalName='${logicalName}')?$select=EntitySetName`,
                {
                    headers: {
                        'Accept': 'application/json',
                        'OData-MaxVersion': '4.0',
                        'OData-Version': '4.0'
                    }
                }
            );
            
            if (response.ok) {
                const data = await response.json();
                return data.EntitySetName;
            }
        } catch (e) {
            console.error('Error getting entity set name:', e);
        }
        
        // Fallback: guess the plural form
        if (logicalName.endsWith('y')) {
            return logicalName.slice(0, -1) + 'ies';
        } else if (logicalName.endsWith('s') || logicalName.endsWith('x') || logicalName.endsWith('ch') || logicalName.endsWith('sh')) {
            return logicalName + 'es';
        }
        return logicalName + 's';
    }

    async function discoverFileColumns() {
        console.log('Discovering file columns for:', viewerConfig.tableName);
        
        try {
            // Get File attributes
            const fileResponse = await fetch(
                `${viewerConfig.baseUrl}/api/data/v9.2/EntityDefinitions(LogicalName='${viewerConfig.tableName}')/Attributes/Microsoft.Dynamics.CRM.FileAttributeMetadata?$select=LogicalName,DisplayName,SchemaName`,
                {
                    headers: {
                        'Accept': 'application/json',
                        'OData-MaxVersion': '4.0',
                        'OData-Version': '4.0'
                    }
                }
            );
            
            if (fileResponse.ok) {
                const fileData = await fileResponse.json();
                console.log('File columns found:', fileData.value);
                
                for (const attr of fileData.value) {
                    viewerConfig.fileColumns.push({
                        logicalName: attr.LogicalName,
                        displayName: attr.DisplayName?.UserLocalizedLabel?.Label || attr.SchemaName || attr.LogicalName,
                        type: 'File'
                    });
                }
            }
            
            // Also get Image attributes (they can also store documents)
            const imageResponse = await fetch(
                `${viewerConfig.baseUrl}/api/data/v9.2/EntityDefinitions(LogicalName='${viewerConfig.tableName}')/Attributes/Microsoft.Dynamics.CRM.ImageAttributeMetadata?$select=LogicalName,DisplayName,SchemaName`,
                {
                    headers: {
                        'Accept': 'application/json',
                        'OData-MaxVersion': '4.0',
                        'OData-Version': '4.0'
                    }
                }
            );
            
            if (imageResponse.ok) {
                const imageData = await imageResponse.json();
                console.log('Image columns found:', imageData.value);
                
                for (const attr of imageData.value) {
                    // Skip the default entity image
                    if (attr.LogicalName === 'entityimage') continue;
                    
                    viewerConfig.fileColumns.push({
                        logicalName: attr.LogicalName,
                        displayName: attr.DisplayName?.UserLocalizedLabel?.Label || attr.SchemaName || attr.LogicalName,
                        type: 'Image'
                    });
                }
            }
            
            console.log('Total file columns discovered:', viewerConfig.fileColumns.length);
            
        } catch (e) {
            console.error('Error discovering file columns:', e);
        }
        
        return viewerConfig.fileColumns;
    }

    async function checkWhichColumnsHaveFiles() {
        if (!viewerConfig.fileColumns.length || !viewerConfig.recordId) return;
        
        try {
            // Fetch the record to see which columns have files
            const columns = viewerConfig.fileColumns.map(c => c.logicalName).join(',');
            const response = await fetch(
                `${viewerConfig.baseUrl}/api/data/v9.2/${viewerConfig.tableSetName}(${viewerConfig.recordId})?$select=${columns}`,
                {
                    headers: {
                        'Accept': 'application/json',
                        'OData-MaxVersion': '4.0',
                        'OData-Version': '4.0'
                    }
                }
            );
            
            if (response.ok) {
                const record = await response.json();
                
                for (const col of viewerConfig.fileColumns) {
                    // File columns have a value when populated
                    col.hasFile = !!record[col.logicalName];
                }
            }
        } catch (e) {
            console.error('Error checking file columns:', e);
        }
    }

    // ========== Configuration UI ==========
    function showConfigUI() {
        hideLoading();
        
        const hasContext = viewerConfig.tableName && viewerConfig.recordId;
        const hasColumns = viewerConfig.fileColumns.length > 0;
        const columnsWithFiles = viewerConfig.fileColumns.filter(c => c.hasFile);
        
        let html = `
            <div class="config-panel">
                <h2>üìÑ Document Viewer</h2>
                <p class="subtitle">Select which document to display</p>
                
                <div class="config-detected">
                    <div class="config-detected-item">
                        <div class="label">Table</div>
                        <div class="value ${viewerConfig.tableName ? 'success' : 'error'}">
                            ${viewerConfig.tableName || 'Not detected'}
                        </div>
                    </div>
                    <div class="config-detected-item">
                        <div class="label">Record ID</div>
                        <div class="value ${viewerConfig.recordId ? 'success' : 'error'}">
                            ${viewerConfig.recordId ? viewerConfig.recordId.substring(0, 8) + '...' : 'Not detected'}
                        </div>
                    </div>
                </div>
        `;
        
        // Show default column info if configured
        if (viewerConfig.defaultColumn) {
            const defaultColInfo = viewerConfig.fileColumns.find(c => c.logicalName === viewerConfig.defaultColumn);
            const hasFile = defaultColInfo?.hasFile;
            
            html += `
                <div class="config-info" style="background: ${hasFile ? 'var(--info-bg)' : '#fff3e0'}; border-color: ${hasFile ? 'var(--info-border)' : '#ffb74d'};">
                    <strong style="color: ${hasFile ? 'var(--info-color)' : '#e65100'};">
                        ${hasFile ? '‚úì' : '‚ö†Ô∏è'} Default Column: ${viewerConfig.defaultColumn}
                    </strong>
                    <p style="margin: 4px 0 0 0; font-size: 12px;">
                        ${hasFile 
                            ? 'This column has a file but multiple files are available. Select which to view.' 
                            : defaultColInfo 
                                ? 'This column exists but has no file attached to this record.' 
                                : 'This column was not found on the table. Check the schema name.'}
                    </p>
                </div>
            `;
        }
        
        if (!hasContext) {
            html += `
                <div class="config-info" style="background: var(--error-bg); border-color: var(--error-border);">
                    <strong style="color: var(--error-color);">‚ö†Ô∏è Could not detect form context</strong>
                    <p style="margin: 8px 0 0 0; font-size: 12px;">
                        Make sure:<br>
                        ‚Ä¢ The web resource is placed on a form<br>
                        ‚Ä¢ "Pass record object-type code and unique identifier as parameters" is checked
                    </p>
                </div>
            `;
        } else if (!hasColumns) {
            html += `
                <div class="config-info" style="background: var(--warning-color); border-color: var(--warning-color); color: white;">
                    <strong>No file columns found</strong>
                    <p style="margin: 8px 0 0 0; font-size: 12px;">
                        This table doesn't have any File or Image columns.
                    </p>
                </div>
            `;
        } else {
            html += `
                <div class="config-section">
                    <label for="fileColumnSelect">Select File Column</label>
                    <select id="fileColumnSelect" class="config-select">
                        <option value="">-- Choose a column --</option>
            `;
            
            for (const col of viewerConfig.fileColumns) {
                const hasFileIndicator = col.hasFile ? ' ‚úì' : ' (empty)';
                const disabled = !col.hasFile ? 'disabled' : '';
                const isDefault = col.logicalName === viewerConfig.defaultColumn ? ' ‚≠ê' : '';
                html += `<option value="${col.logicalName}" ${disabled}>${col.displayName}${hasFileIndicator}${isDefault}</option>`;
            }
            
            html += `
                    </select>
                    <div class="hint">Columns marked with ‚úì have files attached${viewerConfig.defaultColumn ? ', ‚≠ê is the configured default' : ''}</div>
                </div>
                
                <button class="config-btn" id="loadFileBtn" onclick="loadSelectedFile()" disabled>
                    Load Document
                </button>
            `;
            
            if (columnsWithFiles.length === 0) {
                html += `
                    <div class="no-files-message">
                        <p>üì≠ No files are attached to this record yet.</p>
                    </div>
                `;
            }
        }
        
        html += `</div>`;
        
        elements.canvas.innerHTML = html;
        
        // Add event listener for dropdown
        const select = document.getElementById('fileColumnSelect');
        const loadBtn = document.getElementById('loadFileBtn');
        
        if (select && loadBtn) {
            select.addEventListener('change', function() {
                loadBtn.disabled = !this.value;
            });
            
            // Auto-select priority: default column > saved preference > only option
            const savedColumn = loadColumnPreference();
            
            if (viewerConfig.defaultColumn && columnsWithFiles.find(c => c.logicalName === viewerConfig.defaultColumn)) {
                select.value = viewerConfig.defaultColumn;
                loadBtn.disabled = false;
            } else if (savedColumn && columnsWithFiles.find(c => c.logicalName === savedColumn)) {
                select.value = savedColumn;
                loadBtn.disabled = false;
            } else if (columnsWithFiles.length === 1) {
                select.value = columnsWithFiles[0].logicalName;
                loadBtn.disabled = false;
            }
        }
    }

    function loadSelectedFile() {
        const select = document.getElementById('fileColumnSelect');
        if (!select || !select.value) return;
        
        viewerConfig.selectedColumn = select.value;
        saveColumnPreference(select.value);
        
        loadDocument(select.value);
    }

    function populateColumnSelector() {
        const selector = elements.columnSelector;
        if (!selector) return;
        
        selector.innerHTML = '';
        
        for (const col of viewerConfig.fileColumns) {
            if (!col.hasFile) continue;
            
            const option = document.createElement('option');
            option.value = col.logicalName;
            const isDefault = col.logicalName === viewerConfig.defaultColumn ? ' ‚≠ê' : '';
            option.textContent = col.displayName + isDefault;
            option.selected = col.logicalName === viewerConfig.selectedColumn;
            selector.appendChild(option);
        }
        
        // Hide selector if only one column
        const columnsWithFiles = viewerConfig.fileColumns.filter(c => c.hasFile);
        selector.style.display = columnsWithFiles.length <= 1 ? 'none' : 'block';
    }

    function onColumnChange(columnName) {
        if (!columnName || columnName === viewerConfig.selectedColumn) return;
        
        viewerConfig.selectedColumn = columnName;
        saveColumnPreference(columnName);
        loadDocument(columnName);
    }

    // ========== Document Loading ==========
    async function loadDocument(columnName) {
        showLoading('Loading document...');
        showViewerUI();
        
        state.currentFileUrl = `${viewerConfig.baseUrl}/api/data/v9.2/${viewerConfig.tableSetName}(${viewerConfig.recordId})/${columnName}/$value`;
        
        const col = viewerConfig.fileColumns.find(c => c.logicalName === columnName);
        state.currentFileName = col?.displayName || columnName;
        
        console.log('Loading file from:', state.currentFileUrl);
        
        // Try to detect file type from actual content
        try {
            const headResponse = await fetch(state.currentFileUrl, {
                method: 'HEAD',
                headers: {
                    'Accept': '*/*'
                }
            });
            
            const contentType = headResponse.headers.get('Content-Type') || '';
            console.log('Content-Type:', contentType);
            
            if (contentType.includes('pdf')) {
                displayPDF(state.currentFileUrl, state.currentFileName);
            } else if (contentType.includes('image')) {
                displayImg(state.currentFileUrl, state.currentFileName);
            } else {
                // Default to PDF, will fallback to image if it fails
                displayPDF(state.currentFileUrl, state.currentFileName);
            }
        } catch (e) {
            console.log('HEAD request failed, trying PDF:', e);
            displayPDF(state.currentFileUrl, state.currentFileName);
        }
        
        populateColumnSelector();
    }

    // ========== Notifications ==========
    function showLoading(message = 'Loading...', progress = null) {
        elements.loadingOverlay.style.display = 'flex';
        elements.loadingText.textContent = message;
        if (progress !== null) {
            elements.progressBar.style.width = `${progress}%`;
        }
    }

    function hideLoading() {
        elements.loadingOverlay.style.display = 'none';
    }

    function showError(message) {
        elements.canvas.innerHTML = `
            <div class="error-container">
                <div class="error-icon">‚ö†Ô∏è</div>
                <div class="error-message">${escapeHtml(message)}</div>
                <button class="config-btn" style="max-width: 200px; margin: 16px auto;" onclick="location.reload()">üîÑ Retry</button>
            </div>
        `;
    }

    function updateProgress(percent) {
        elements.progressBar.style.width = `${Math.round(percent)}%`;
    }

    // ========== UI Updates ==========
    function showViewerUI() {
        document.getElementById('toolbar').style.display = 'flex';
        document.getElementById('sidebar').style.display = 'flex';
    }

    function updatePageInfo() {
        elements.totalPages.textContent = state.totalPages;
        elements.pageInput.max = state.totalPages;
        elements.pageInput.value = state.currentPage;
        elements.prevPage.disabled = state.currentPage <= 1;
        elements.nextPage.disabled = state.currentPage >= state.totalPages;
        
        document.querySelectorAll('.thumbnail-item').forEach((thumb, i) => {
            thumb.classList.toggle('active', i + 1 === state.currentPage);
        });
    }

    function updateZoomSelect() {
        const select = elements.zoomSelect;
        const percent = Math.round(state.currentScale * 100);
        
        let found = false;
        for (let option of select.options) {
            if (option.value === state.fitMode) {
                option.selected = true;
                found = true;
                break;
            } else if (parseFloat(option.value) === state.currentScale) {
                option.selected = true;
                found = true;
                break;
            }
        }
        
        if (!found) {
            let customOption = select.querySelector('option[data-custom]');
            if (!customOption) {
                customOption = document.createElement('option');
                customOption.dataset.custom = true;
                select.insertBefore(customOption, select.firstChild);
            }
            customOption.value = state.currentScale;
            customOption.textContent = `${percent}%`;
            customOption.selected = true;
        }
    }

    // ========== Sidebar ==========
    function toggleSidebar(silent = false) {
        state.sidebarVisible = !state.sidebarVisible;
        elements.sidebar.classList.toggle('collapsed', !state.sidebarVisible);
        elements.sidebarToggle.classList.toggle('active', state.sidebarVisible);
        if (!silent) saveViewPreferences();
    }

    function showSidebarPanel(panelName) {
        document.querySelectorAll('.sidebar-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.panel === panelName);
        });
        document.querySelectorAll('.sidebar-panel').forEach(panel => {
            panel.classList.toggle('active', panel.id === `${panelName}Panel`);
        });
    }

    // ========== Thumbnails ==========
    async function renderThumbnails() {
        if (!state.pdfDoc) return;
        
        const container = elements.thumbnailContainer;
        container.innerHTML = '';
        
        for (let i = 1; i <= state.totalPages; i++) {
            const item = document.createElement('div');
            item.className = 'thumbnail-item';
            if (i === state.currentPage) item.classList.add('active');
            item.onclick = () => goToPage(i);
            
            const page = await state.pdfDoc.getPage(i);
            const viewport = page.getViewport({ scale: CONFIG.THUMBNAIL_SCALE });
            
            const canvas = document.createElement('canvas');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            await page.render({
                canvasContext: canvas.getContext('2d'),
                viewport
            }).promise;
            
            const label = document.createElement('div');
            label.className = 'thumbnail-label';
            label.textContent = `Page ${i}`;
            
            item.appendChild(canvas);
            item.appendChild(label);
            container.appendChild(item);
        }
    }

    // ========== Outline ==========
    async function renderOutline() {
        if (!state.pdfDoc) return;
        
        const container = elements.outlineContainer;
        
        try {
            const outline = await state.pdfDoc.getOutline();
            
            if (!outline || outline.length === 0) {
                container.innerHTML = '<div style="padding: 16px; color: var(--text-muted); text-align: center;">No outline available</div>';
                return;
            }
            
            container.innerHTML = '';
            renderOutlineItems(outline, container, 1);
        } catch (e) {
            container.innerHTML = '<div style="padding: 16px; color: var(--text-muted);">Could not load outline</div>';
        }
    }

    function renderOutlineItems(items, container, level) {
        items.forEach(item => {
            const div = document.createElement('div');
            div.className = `outline-item level-${Math.min(level, 3)}`;
            div.textContent = item.title;
            div.onclick = async () => {
                if (item.dest) {
                    try {
                        const dest = typeof item.dest === 'string' 
                            ? await state.pdfDoc.getDestination(item.dest)
                            : item.dest;
                        const pageIndex = await state.pdfDoc.getPageIndex(dest[0]);
                        goToPage(pageIndex + 1);
                    } catch (e) {}
                }
            };
            container.appendChild(div);
            
            if (item.items && item.items.length > 0) {
                renderOutlineItems(item.items, container, level + 1);
            }
        });
    }

    // ========== PDF Rendering ==========
    function calculateScale(fitMode) {
        if (!state.pdfDoc || !state.pageViewports.length) return CONFIG.DEFAULT_SCALE;
        
        const viewport = state.pageViewports[0];
        const container = elements.canvas;
        const containerWidth = container.clientWidth - 60;
        const containerHeight = container.clientHeight - 40;
        
        const rotation = state.currentRotation % 180 !== 0;
        const pageWidth = rotation ? viewport.height : viewport.width;
        const pageHeight = rotation ? viewport.width : viewport.height;
        
        switch (fitMode) {
            case 'page-width':
                return containerWidth / pageWidth;
            case 'page-fit':
                return Math.min(containerWidth / pageWidth, containerHeight / pageHeight);
            case 'auto':
                return Math.min(1, containerWidth / pageWidth);
            default:
                return parseFloat(fitMode) || CONFIG.DEFAULT_SCALE;
        }
    }

    async function renderPage(pageNum) {
        if (!state.pdfDoc || pageNum < 1 || pageNum > state.totalPages) return null;
        
        const page = await state.pdfDoc.getPage(pageNum);
        const dpr = window.devicePixelRatio || 1;
        const scale = state.currentScale * dpr;
        
        const viewport = page.getViewport({ scale, rotation: state.currentRotation });
        
        const wrapper = document.createElement('div');
        wrapper.className = 'pdf-page-wrapper';
        wrapper.dataset.pageNum = pageNum;
        wrapper.style.width = `${viewport.width / dpr}px`;
        wrapper.style.height = `${viewport.height / dpr}px`;
        
        const canvas = document.createElement('canvas');
        canvas.className = 'pdf-page';
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        canvas.style.width = `${viewport.width / dpr}px`;
        canvas.style.height = `${viewport.height / dpr}px`;
        
        await page.render({
            canvasContext: canvas.getContext('2d'),
            viewport
        }).promise;
        
        wrapper.appendChild(canvas);
        
        // Text layer
        const textLayer = document.createElement('div');
        textLayer.className = 'text-layer';
        
        const textContent = await page.getTextContent();
        state.textContent.set(pageNum, textContent);
        
        const textViewport = page.getViewport({ scale: state.currentScale, rotation: state.currentRotation });
        
        textContent.items.forEach(item => {
            const span = document.createElement('span');
            span.textContent = item.str;
            
            const tx = pdfjsLib.Util.transform(textViewport.transform, item.transform);
            const fontSize = Math.sqrt(tx[0] * tx[0] + tx[1] * tx[1]);
            const angle = Math.atan2(tx[1], tx[0]);
            
            span.style.left = `${tx[4]}px`;
            span.style.top = `${tx[5] - fontSize}px`;
            span.style.fontSize = `${fontSize}px`;
            span.style.fontFamily = item.fontName || 'sans-serif';
            
            if (angle !== 0) {
                span.style.transform = `rotate(${angle}rad)`;
            }
            
            textLayer.appendChild(span);
        });
        
        wrapper.appendChild(textLayer);
        
        if (state.searchText) {
            highlightSearchInPage(pageNum, textLayer);
        }
        
        return wrapper;
    }

    async function renderAllPages() {
        const container = elements.canvas;
        container.innerHTML = '';
        
        const pageContainer = document.createElement('div');
        pageContainer.className = 'page-container';
        container.appendChild(pageContainer);
        
        state.renderedPages.clear();
        
        for (let i = 1; i <= state.totalPages; i++) {
            const viewport = state.pageViewports[i - 1];
            const dpr = window.devicePixelRatio || 1;
            const rotation = state.currentRotation % 180 !== 0;
            
            const width = (rotation ? viewport.height : viewport.width) * state.currentScale;
            const height = (rotation ? viewport.width : viewport.height) * state.currentScale;
            
            const placeholder = document.createElement('div');
            placeholder.className = 'pdf-page-placeholder';
            placeholder.dataset.pageNum = i;
            placeholder.style.width = `${width}px`;
            placeholder.style.height = `${height}px`;
            
            pageContainer.appendChild(placeholder);
        }
        
        await renderVisiblePages();
        hideLoading();
    }

    async function renderVisiblePages() {
        const container = elements.canvas;
        const pageContainer = container.querySelector('.page-container');
        if (!pageContainer) return;
        
        const scrollTop = container.scrollTop;
        const viewportTop = scrollTop - CONFIG.RENDER_BUFFER_PX;
        const viewportBottom = scrollTop + container.clientHeight + CONFIG.RENDER_BUFFER_PX;
        
        const elementsToRender = pageContainer.querySelectorAll('.pdf-page-placeholder, .pdf-page-wrapper');
        
        for (const el of elementsToRender) {
            const pageNum = parseInt(el.dataset.pageNum, 10);
            const top = el.offsetTop;
            const bottom = top + el.offsetHeight;
            
            if (bottom >= viewportTop && top <= viewportBottom) {
                if (el.classList.contains('pdf-page-placeholder') && !state.renderedPages.has(pageNum)) {
                    state.renderedPages.set(pageNum, 'rendering');
                    
                    try {
                        const rendered = await renderPage(pageNum);
                        if (rendered && el.parentNode) {
                            el.parentNode.replaceChild(rendered, el);
                            state.renderedPages.set(pageNum, 'done');
                        }
                    } catch (e) {
                        console.error(`Error rendering page ${pageNum}:`, e);
                        state.renderedPages.delete(pageNum);
                    }
                }
            }
        }
    }

    const throttledRenderVisible = throttle(renderVisiblePages, CONFIG.SCROLL_THROTTLE_MS);

    function handleScroll() {
        const container = elements.canvas;
        const pageContainer = container.querySelector('.page-container');
        if (!pageContainer) return;
        
        const scrollTop = container.scrollTop;
        const containerHeight = container.clientHeight;
        
        const pages = pageContainer.querySelectorAll('.pdf-page-wrapper, .pdf-page-placeholder');
        let mostVisible = 1;
        let maxVisible = 0;
        
        pages.forEach(page => {
            const pageNum = parseInt(page.dataset.pageNum, 10);
            const top = page.offsetTop;
            const bottom = top + page.offsetHeight;
            
            const visibleTop = Math.max(scrollTop, top);
            const visibleBottom = Math.min(scrollTop + containerHeight, bottom);
            const visible = Math.max(0, visibleBottom - visibleTop);
            
            if (visible > maxVisible) {
                maxVisible = visible;
                mostVisible = pageNum;
            }
        });
        
        if (mostVisible !== state.currentPage) {
            state.currentPage = mostVisible;
            updatePageInfo();
        }
        
        throttledRenderVisible();
    }

    // ========== Image Display ==========
    function displayImg(url, fileName) {
        showLoading('Loading image...');
        
        const img = document.createElement('img');
        
        img.onerror = () => {
            hideLoading();
            showError('Could not load file. The file may be corrupted or in an unsupported format.');
        };
        
        img.onload = () => {
            const container = elements.canvas;
            container.innerHTML = '';
            
            const wrapper = document.createElement('div');
            wrapper.className = 'page-container';
            wrapper.appendChild(img);
            container.appendChild(wrapper);
            
            img.style.maxWidth = '100%';
            img.style.transform = `scale(${state.currentScale}) rotate(${state.currentRotation}deg)`;
            img.style.transformOrigin = 'center center';
            img.style.transition = 'transform 0.2s';
            
            state.currentFileType = 'image';
            state.totalPages = 1;
            state.currentPage = 1;
            updatePageInfo();
            hideLoading();
        };
        
        img.alt = 'Document Image';
        img.draggable = false;
        img.src = addCacheBuster(url);
    }

    // ========== PDF Loading ==========
    async function displayPDF(url, fileName) {
        if (state.loadController) {
            state.loadController.abort();
        }
        state.loadController = new AbortController();
        
        showLoading('Loading PDF...', 0);
        state.isLoading = true;
        
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = CONFIG.PDF_WORKER_URL;
        }
        
        try {
            const loadingTask = pdfjsLib.getDocument({
                url: addCacheBuster(url),
                cMapUrl: CONFIG.PDF_CMAP_URL,
                cMapPacked: true
            });
            
            loadingTask.onProgress = (progress) => {
                if (progress.total > 0) {
                    updateProgress((progress.loaded / progress.total) * 100);
                }
            };
            
            const pdf = await loadingTask.promise;
            
            state.pdfDoc = pdf;
            state.totalPages = pdf.numPages;
            state.currentPage = 1;
            state.currentFileType = 'pdf';
            state.isLoading = false;
            
            state.pageViewports = [];
            for (let i = 1; i <= state.totalPages; i++) {
                const page = await pdf.getPage(i);
                state.pageViewports.push(page.getViewport({ scale: 1 }));
            }
            
            const metadata = await pdf.getMetadata().catch(() => null);
            state.docInfo = {
                fileName: state.currentFileName,
                pageCount: state.totalPages,
                title: metadata?.info?.Title || '',
                author: metadata?.info?.Author || '',
                subject: metadata?.info?.Subject || '',
                creator: metadata?.info?.Creator || ''
            };
            
            updatePageInfo();
            await renderAllPages();
            
            setTimeout(() => {
                renderThumbnails();
                renderOutline();
            }, 100);
            
        } catch (error) {
            state.isLoading = false;
            
            if (error.name === 'AbortError') return;
            
            console.error('PDF load failed:', error);
            
            // Try as image instead
            displayImg(url, fileName);
        }
    }

    // ========== Navigation ==========
    function goToPage(pageNum) {
        pageNum = parseInt(pageNum, 10);
        if (isNaN(pageNum) || pageNum < 1 || pageNum > state.totalPages) return;
        
        state.currentPage = pageNum;
        updatePageInfo();
        
        const page = elements.canvas.querySelector(`[data-page-num="${pageNum}"]`);
        if (page) {
            page.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    function previousPage() {
        if (state.currentPage > 1) goToPage(state.currentPage - 1);
    }

    function nextPage() {
        if (state.currentPage < state.totalPages) goToPage(state.currentPage + 1);
    }

    // ========== Zoom ==========
    function setZoom(value) {
        if (['auto', 'page-fit', 'page-width'].includes(value)) {
            state.fitMode = value;
            state.currentScale = calculateScale(value);
        } else {
            state.fitMode = null;
            state.currentScale = parseFloat(value) || CONFIG.DEFAULT_SCALE;
        }
        
        state.currentScale = Math.max(CONFIG.MIN_SCALE, Math.min(CONFIG.MAX_SCALE, state.currentScale));
        updateZoomSelect();
        refreshDisplay();
    }

    function zoomIn() {
        state.fitMode = null;
        state.currentScale = Math.min(state.currentScale * CONFIG.ZOOM_STEP, CONFIG.MAX_SCALE);
        updateZoomSelect();
        refreshDisplay();
    }

    function zoomOut() {
        state.fitMode = null;
        state.currentScale = Math.max(state.currentScale / CONFIG.ZOOM_STEP, CONFIG.MIN_SCALE);
        updateZoomSelect();
        refreshDisplay();
    }

    function resetZoom() {
        state.fitMode = null;
        state.currentScale = CONFIG.DEFAULT_SCALE;
        updateZoomSelect();
        refreshDisplay();
    }

    // ========== Rotation ==========
    function rotateLeft() {
        state.currentRotation = (state.currentRotation - 90 + 360) % 360;
        refreshDisplay();
    }

    function rotateRight() {
        state.currentRotation = (state.currentRotation + 90) % 360;
        refreshDisplay();
    }

    // ========== Refresh ==========
    async function refreshDisplay() {
        state.renderedPages.clear();
        state.textContent.clear();
        
        if (state.fitMode) {
            state.currentScale = calculateScale(state.fitMode);
        }
        
        if (state.currentFileType === 'pdf' && state.pdfDoc) {
            showLoading('Rendering...');
            await renderAllPages();
            goToPage(state.currentPage);
        } else if (state.currentFileType === 'image') {
            const img = elements.canvas.querySelector('img');
            if (img) {
                img.style.transform = `scale(${state.currentScale}) rotate(${state.currentRotation}deg)`;
            }
        }
    }

    // ========== Search ==========
    function performSearch(text) {
        state.searchText = text.toLowerCase();
        state.searchMatches = [];
        state.currentMatchIndex = -1;
        
        if (!state.searchText) {
            clearSearchHighlights();
            elements.searchResults.textContent = '';
            return;
        }
        
        state.textContent.forEach((content, pageNum) => {
            content.items.forEach((item, itemIndex) => {
                const str = item.str.toLowerCase();
                let pos = 0;
                while ((pos = str.indexOf(state.searchText, pos)) !== -1) {
                    state.searchMatches.push({ pageNum, itemIndex, pos });
                    pos += state.searchText.length;
                }
            });
        });
        
        if (state.searchMatches.length > 0) {
            elements.searchResults.textContent = `${state.searchMatches.length} found`;
            state.currentMatchIndex = 0;
            highlightCurrentMatch();
        } else {
            elements.searchResults.textContent = 'No results';
        }
        
        document.querySelectorAll('.text-layer').forEach(layer => {
            const pageNum = parseInt(layer.parentElement.dataset.pageNum, 10);
            highlightSearchInPage(pageNum, layer);
        });
    }

    function highlightSearchInPage(pageNum, textLayer) {
        textLayer.querySelectorAll('.highlight').forEach(el => {
            el.classList.remove('highlight', 'active');
        });
        
        if (!state.searchText) return;
        
        const content = state.textContent.get(pageNum);
        if (!content) return;
        
        const spans = textLayer.querySelectorAll('span');
        
        content.items.forEach((item, itemIndex) => {
            const str = item.str.toLowerCase();
            if (str.includes(state.searchText)) {
                const span = spans[itemIndex];
                if (span) {
                    span.classList.add('highlight');
                    
                    const match = state.searchMatches[state.currentMatchIndex];
                    if (match && match.pageNum === pageNum && match.itemIndex === itemIndex) {
                        span.classList.add('active');
                    }
                }
            }
        });
    }

    function highlightCurrentMatch() {
        if (state.currentMatchIndex < 0 || state.currentMatchIndex >= state.searchMatches.length) return;
        
        const match = state.searchMatches[state.currentMatchIndex];
        elements.searchResults.textContent = `${state.currentMatchIndex + 1} of ${state.searchMatches.length}`;
        
        goToPage(match.pageNum);
        
        setTimeout(() => {
            document.querySelectorAll('.text-layer .highlight').forEach(el => {
                el.classList.remove('active');
            });
            
            const page = elements.canvas.querySelector(`[data-page-num="${match.pageNum}"]`);
            if (page) {
                const textLayer = page.querySelector('.text-layer');
                if (textLayer) {
                    highlightSearchInPage(match.pageNum, textLayer);
                }
            }
        }, 100);
    }

    function clearSearchHighlights() {
        document.querySelectorAll('.text-layer .highlight').forEach(el => {
            el.classList.remove('highlight', 'active');
        });
    }

    function searchNext() {
        if (state.searchMatches.length === 0) return;
        state.currentMatchIndex = (state.currentMatchIndex + 1) % state.searchMatches.length;
        highlightCurrentMatch();
    }

    function searchPrev() {
        if (state.searchMatches.length === 0) return;
        state.currentMatchIndex = (state.currentMatchIndex - 1 + state.searchMatches.length) % state.searchMatches.length;
        highlightCurrentMatch();
    }

    function handleSearchKeydown(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            if (e.shiftKey) searchPrev();
            else if (state.searchMatches.length === 0) performSearch(elements.searchInput.value);
            else searchNext();
        } else if (e.key === 'Escape') {
            elements.searchInput.value = '';
            performSearch('');
            elements.searchInput.blur();
        }
    }

    // ========== Dark Mode ==========
    function toggleDarkMode(silent = false) {
        state.darkMode = !state.darkMode;
        document.documentElement.dataset.theme = state.darkMode ? 'dark' : 'light';
        elements.darkModeToggle.classList.toggle('active', state.darkMode);
        if (!silent) saveViewPreferences();
    }

    // ========== Fullscreen ==========
    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            elements.appContainer.requestFullscreen().catch(console.log);
        } else {
            document.exitFullscreen();
        }
    }

    // ========== Print ==========
    function printDocument() {
        window.print();
    }

    // ========== Download ==========
    function downloadFile() {
        if (!state.currentFileUrl) return;
        
        try {
            let fileName = state.currentFileName || 'document';
            const ext = getFileExtension(fileName);
            if (!ext) fileName += state.currentFileType === 'pdf' ? '.pdf' : '.jpg';
            
            const link = document.createElement('a');
            link.href = state.currentFileUrl;
            link.download = fileName;
            link.target = '_blank';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (e) {
            window.open(state.currentFileUrl, '_blank');
        }
    }

    // ========== Document Info ==========
    function showDocInfo() {
        const panel = elements.docInfoPanel;
        if (panel.classList.contains('visible')) {
            panel.classList.remove('visible');
            return;
        }
        
        let html = '';
        const info = state.docInfo || {};
        
        const rows = [
            ['File Column', viewerConfig.selectedColumn],
            ['Pages', state.totalPages],
            ['Title', info.title],
            ['Author', info.author]
        ];
        
        rows.forEach(([label, value]) => {
            if (value) {
                html += `<div class="doc-info-row">
                    <span class="label">${label}</span>
                    <span class="value">${escapeHtml(String(value))}</span>
                </div>`;
            }
        });
        
        elements.docInfoContent.innerHTML = html;
        panel.classList.add('visible');
        
        setTimeout(() => {
            document.addEventListener('click', closeDocInfoOnClickOutside);
        }, 0);
    }

    function closeDocInfoOnClickOutside(e) {
        if (!elements.docInfoPanel.contains(e.target) && e.target.getAttribute('aria-label') !== 'Document info') {
            elements.docInfoPanel.classList.remove('visible');
            document.removeEventListener('click', closeDocInfoOnClickOutside);
        }
    }

    // ========== Shortcuts ==========
    function showShortcuts() {
        elements.shortcutsModal.classList.add('visible');
    }

    function hideShortcuts() {
        elements.shortcutsModal.classList.remove('visible');
    }

    // ========== Input Handlers ==========
    function initDragHandlers() {
        const canvas = elements.canvas;
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0 || e.target.closest('.text-layer')) return;
            
            state.isDragging = true;
            state.dragStart = {
                x: e.clientX,
                y: e.clientY,
                scrollLeft: canvas.scrollLeft,
                scrollTop: canvas.scrollTop
            };
            canvas.classList.add('grabbing');
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!state.isDragging) return;
            canvas.scrollLeft = state.dragStart.scrollLeft - (e.clientX - state.dragStart.x);
            canvas.scrollTop = state.dragStart.scrollTop - (e.clientY - state.dragStart.y);
        });
        
        canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
            canvas.classList.remove('grabbing');
        });
        
        canvas.addEventListener('mouseleave', () => {
            state.isDragging = false;
            canvas.classList.remove('grabbing');
        });
        
        canvas.addEventListener('dblclick', (e) => {
            if (e.target.closest('.text-layer')) return;
            state.currentScale = state.currentScale < 2 ? 2 : 1;
            state.fitMode = null;
            updateZoomSelect();
            refreshDisplay();
        });
    }

    function initTouchHandlers() {
        const canvas = elements.canvas;
        
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                state.touchState.initialPinchDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                state.touchState.initialScale = state.currentScale;
            }
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && state.touchState.initialPinchDistance) {
                e.preventDefault();
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                state.currentScale = Math.min(Math.max(
                    (dist / state.touchState.initialPinchDistance) * state.touchState.initialScale,
                    CONFIG.MIN_SCALE
                ), CONFIG.MAX_SCALE);
                state.fitMode = null;
                updateZoomSelect();
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', () => {
            if (state.touchState.initialPinchDistance) {
                state.touchState.initialPinchDistance = 0;
                refreshDisplay();
            }
        });
    }

    function initKeyboardHandlers() {
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' && e.target.id !== 'searchInput') return;
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
            
            if (elements.shortcutsModal.classList.contains('visible')) {
                if (e.key === 'Escape') hideShortcuts();
                return;
            }
            
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'f': e.preventDefault(); elements.searchInput.focus(); elements.searchInput.select(); break;
                    case 'p': e.preventDefault(); printDocument(); break;
                    case '0': e.preventDefault(); resetZoom(); break;
                }
                return;
            }
            
            if (e.target.id !== 'searchInput') {
                switch (e.key) {
                    case 'ArrowLeft': case 'PageUp': e.preventDefault(); previousPage(); break;
                    case 'ArrowRight': case 'PageDown': case ' ': e.preventDefault(); nextPage(); break;
                    case 'Home': e.preventDefault(); goToPage(1); break;
                    case 'End': e.preventDefault(); goToPage(state.totalPages); break;
                    case '+': case '=': e.preventDefault(); zoomIn(); break;
                    case '-': case '_': e.preventDefault(); zoomOut(); break;
                    case '0': e.preventDefault(); resetZoom(); break;
                    case 'r': case 'R': e.preventDefault(); rotateRight(); break;
                    case 'f': case 'F': e.preventDefault(); toggleFullscreen(); break;
                    case 'b': case 'B': e.preventDefault(); toggleSidebar(); break;
                    case 'd': case 'D': e.preventDefault(); toggleDarkMode(); break;
                    case 'i': case 'I': e.preventDefault(); showDocInfo(); break;
                    case '?': e.preventDefault(); showShortcuts(); break;
                    case 'Escape': elements.docInfoPanel.classList.remove('visible'); break;
                }
            }
        });
    }

    function initOfflineDetection() {
        const updateStatus = () => {
            elements.offlineBanner.classList.toggle('visible', !navigator.onLine);
        };
        window.addEventListener('online', updateStatus);
        window.addEventListener('offline', updateStatus);
        updateStatus();
    }

    // ========== Initialization ==========
    async function init() {
        // Cache DOM elements
        elements.appContainer = document.getElementById('appContainer');
        elements.canvas = document.getElementById('canvas');
        elements.sidebar = document.getElementById('sidebar');
        elements.sidebarToggle = document.getElementById('sidebarToggle');
        elements.thumbnailContainer = document.getElementById('thumbnailContainer');
        elements.outlineContainer = document.getElementById('outlineContainer');
        elements.loadingOverlay = document.getElementById('loadingOverlay');
        elements.loadingText = document.getElementById('loadingText');
        elements.progressBar = document.getElementById('progressBar');
        elements.offlineBanner = document.getElementById('offlineBanner');
        elements.zoomSelect = document.getElementById('zoomSelect');
        elements.pageInput = document.getElementById('pageInput');
        elements.totalPages = document.getElementById('totalPages');
        elements.prevPage = document.getElementById('prevPage');
        elements.nextPage = document.getElementById('nextPage');
        elements.searchInput = document.getElementById('searchInput');
        elements.searchResults = document.getElementById('searchResults');
        elements.darkModeToggle = document.getElementById('darkModeToggle');
        elements.docInfoPanel = document.getElementById('docInfoPanel');
        elements.docInfoContent = document.getElementById('docInfoContent');
        elements.shortcutsModal = document.getElementById('shortcutsModal');
        elements.columnSelector = document.getElementById('columnSelector');
        
        initDragHandlers();
        initTouchHandlers();
        initKeyboardHandlers();
        initOfflineDetection();
        
        elements.canvas.addEventListener('scroll', throttle(handleScroll, CONFIG.SCROLL_THROTTLE_MS));
        elements.searchInput.addEventListener('input', debounce((e) => performSearch(e.target.value), 300));
        window.addEventListener('resize', debounce(() => {
            if (state.fitMode && state.pdfDoc) {
                state.currentScale = calculateScale(state.fitMode);
                refreshDisplay();
            }
        }, 250));
        
        // Parse custom parameters first (for default column)
        parseCustomParameters();
        
        showLoading('Detecting form context...');
        
        // Auto-detect form context
        const hasContext = await detectFormContext();
        
        if (!hasContext) {
            showConfigUI();
            return;
        }
        
        // Get entity set name for API calls
        showLoading('Loading table metadata...');
        viewerConfig.tableSetName = await getEntitySetName(viewerConfig.tableName);
        console.log('Entity set name:', viewerConfig.tableSetName);
        
        // Discover file columns
        showLoading('Discovering file columns...');
        await discoverFileColumns();
        
        if (viewerConfig.fileColumns.length === 0) {
            showConfigUI();
            return;
        }
        
        // Check which columns have files
        showLoading('Checking for files...');
        await checkWhichColumnsHaveFiles();
        
        // Load preferences
        loadViewPreferences();
        
        const columnsWithFiles = viewerConfig.fileColumns.filter(c => c.hasFile);
        
        // Priority for selecting column:
        // 1. Default column from Custom Parameter (if it has a file)
        // 2. Saved preference from localStorage (if it has a file)
        // 3. Auto-select if only one column has a file
        // 4. Show picker if multiple columns have files
        
        let columnToLoad = null;
        
        // Check if default column is set and has a file
        if (viewerConfig.defaultColumn) {
            const defaultCol = columnsWithFiles.find(c => c.logicalName === viewerConfig.defaultColumn);
            if (defaultCol) {
                columnToLoad = viewerConfig.defaultColumn;
                console.log('Using default column from parameter:', columnToLoad);
            } else {
                console.log('Default column specified but not found or empty:', viewerConfig.defaultColumn);
            }
        }
        
        // Fallback to saved preference
        if (!columnToLoad) {
            const savedColumn = loadColumnPreference();
            if (savedColumn && columnsWithFiles.find(c => c.logicalName === savedColumn)) {
                columnToLoad = savedColumn;
                console.log('Using saved column preference:', columnToLoad);
            }
        }
        
        // Fallback to auto-select if only one column
        if (!columnToLoad && columnsWithFiles.length === 1) {
            columnToLoad = columnsWithFiles[0].logicalName;
            console.log('Auto-selecting only column with file:', columnToLoad);
        }
        
        // Load the document or show picker
        if (columnToLoad) {
            viewerConfig.selectedColumn = columnToLoad;
            loadDocument(columnToLoad);
        } else if (columnsWithFiles.length > 1) {
            // Show picker if multiple columns have files
            showConfigUI();
        } else {
            // No files attached
            showConfigUI();
        }
    }

    // Expose global functions
    window.toggleSidebar = toggleSidebar;
    window.showSidebarPanel = showSidebarPanel;
    window.zoomIn = zoomIn;
    window.zoomOut = zoomOut;
    window.setZoom = setZoom;
    window.rotateLeft = rotateLeft;
    window.rotateRight = rotateRight;
    window.previousPage = previousPage;
    window.nextPage = nextPage;
    window.goToPage = goToPage;
    window.searchNext = searchNext;
    window.searchPrev = searchPrev;
    window.handleSearchKeydown = handleSearchKeydown;
    window.toggleDarkMode = toggleDarkMode;
    window.toggleFullscreen = toggleFullscreen;
    window.printDocument = printDocument;
    window.downloadFile = downloadFile;
    window.showDocInfo = showDocInfo;
    window.showShortcuts = showShortcuts;
    window.hideShortcuts = hideShortcuts;
    window.loadSelectedFile = loadSelectedFile;
    window.onColumnChange = onColumnChange;

    // Initialize
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
</script>
</body>
</html>